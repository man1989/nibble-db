{"version":3,"sources":["../index.ts","../lib/db.ts","../lib/collection.ts","../lib/filter.ts","../lib/util.ts"],"sourcesContent":["// global.ROOT_PATH = __dirname + \"/userData\";\n// const util = require(\"./lib/util\");\n// const Collection = require(\"./lib/collection\")(util);\n// const DB = require(\"./lib/db\")(Collection);\n// import { DB } \n// module.exports = DB\nexport { DB } from \"./lib/db\";","import fs from \"node:fs\"\nimport { join } from \"node:path\";\nimport { Collection } from \"./collection\";\nimport { mkdir, stat } from \"node:fs/promises\";\nconst NOT_VALID = \"provide a valid input\";\n\nexport class DB {\n    private static _rootPath: string = join(__dirname, \"../.$$db$$\");\n    private _collections = new Map<string, InstanceType<typeof Collection>>()\n    private _current =  {} as InstanceType<typeof Collection>;\n    readonly name: string ;\n    constructor(name: string){\n        this.name = name;\n        // // this._rootPath = rootPath || this._rootPath;\n        // let path = DB.getPath();\n        // try {\n        //     if (!fs.existsSync(path)) {\n        //         fs.mkdirSync(path);\n        //     }\n        // } catch (err) {\n        //     throw err;\n        // }\n    }\n\n    static getPath(name?: string): string {\n        return this._rootPath + \"/\" + (name || this.name);\n    }\n\n    static async create(name: string, rootPath?: string) {\n        this._rootPath = rootPath || this._rootPath;\n        // console.log(this._rootPath)\n        // const path = this.getPath();\n        try{\n            await stat(this._rootPath)\n        }catch(err){\n            // console.log(\"Not found: \");\n            await mkdir(join(this._rootPath, name), {\n                recursive: true\n            });\n        }\n        return new DB(name)\n    }\n\n    getName() {\n        return this.name;\n    }\n    \n    static use(name: string) {\n        let path = this.getPath(name);\n        return new DB(name);\n    };\n    \n    async useCollection<T extends {}>(name: string): Promise<Collection<T>> {\n        let collection = this._collections.get(name);\n        if(!collection) {\n            collection = await Collection.create<T>(DB._rootPath, this.name + \".\" + name);\n            this._collections.set(name, collection);\n        }\n        this._current = collection;\n        return collection as Collection<T>;\n    };\n    \n    removeCollection(name: string){\n        this._collections.delete(name);\n    }\n\n    getCollectionName() {\n        //return current collection name;\n    };\n    \n    getCollectionList(){\n        // return list of collections\n    };\n\n}","import { readFile, stat, writeFile } from \"node:fs/promises\";\nimport { join } from \"node:path\";\nimport { v4 as uuid } from \"uuid\";\nimport {filter, Query} from \"./filter\";\n\nimport * as util from \"./util\";\n\nconst NOT_VALID = \"provide a valid input\";\ntype Basetype = {\n    _id: string\n}\n\nexport class Collection<T> {\n    private fullName: string;\n    private rootPath: string = join(__dirname, \"userData\");\n\n    constructor(fullName: string, rootPath?: string){\n        this.fullName = fullName;\n        this.rootPath = rootPath || this.rootPath;\n    }\n\n    static async create<CollectionType>(rootPath: string, fullName: string): Promise<Collection<CollectionType>>{\n        let path = rootPath + \"/\" + fullName.split(\".\").join(\"/\");\n        path += \".ldb\";\n        try{\n            await stat(path)\n        }catch(err) {\n            await writeFile(path, \"\");\n        }\n        return new Collection<CollectionType>(fullName, rootPath);\n    }\n\n    private getPath() {\n        let path = this.rootPath + \"/\" + this.fullName.split(\".\").join(\"/\");\n        path += \".ldb\";\n        return path;\n    };\n    \n    async insert(obj: T): Promise<T & Basetype | void> {\n        // util.validateInput(obj);\n        if(util.isEmptyObject(obj as any)) throw NOT_VALID;\n        let uniqueKey = uuid();\n        let path = this.getPath();\n        obj = Object.assign({\n            \"_id\": uniqueKey\n        }, obj);\n        try {\n            let fileData: string = await readFile(path, \"utf-8\") || \"[]\";\n            const data: T[]  = JSON.parse(fileData);\n            data.push(obj);\n            fileData = JSON.stringify(data);\n            return writeFile(path, fileData);\n        } catch (err) {\n            throw err;\n        }\n    };\n    \n    async find(query: Partial<T & Basetype>) {\n        let path = this.getPath();\n        const filtered = filter(query as any);\n\n        let fileData: string = await readFile(path, \"utf-8\");\n\n        try {\n            let results = JSON.parse(fileData) as T[];\n            const filteredRes = filtered.test(results, query);\n            return filteredRes;\n        } catch (err) {}\n    };\n    \n    async update(query: Partial<T & Basetype>, obj: Partial<T>) {\n        util.validateInput(query);\n        util.validateInput(obj);\n     \n        const filtered = filter(query as any);\n        let fileData: string = await readFile(this.getPath(), \"utf-8\");\n        try {\n            let results = JSON.parse(fileData) as (T&Basetype)[];\n            const updates = filtered.test(results, query) as (T&Basetype)[];    \n            (updates as any[]).forEach((row) => {\n                for (let key in obj) {\n                    if (obj.hasOwnProperty(key)) {\n                        row[key] = obj[key];\n                    }\n                }\n            });\n\n            return writeFile(this.getPath(), JSON.stringify(results));\n\n        } catch (err) {}\n    }        \n\n    async delete(query: any){\n        const filtered = filter(query as any);\n        let fileData: string = await readFile(this.getPath(), \"utf-8\");\n        try {\n            let results = JSON.parse(fileData) as (T&Basetype)[];\n            const filteredRes = filtered.test(results, query) as (T&Basetype)[];\n            const deletedData = results.filter((result) => {\n                return filteredRes.findIndex(f=>f._id === result._id) === -1\n            });\n\n            return writeFile(this.getPath(), JSON.stringify(deletedData));\n\n        } catch (err) {}\n    }\n}\n\n","/**\n * filtr - MongoDB inspired array filtering\n * Copyright(c) 2012 Jake Luer <jake@alogicalparadox.com>\n * @see https://github.com/logicalparadox/filtr\n * MIT Licensed\n */\n\n/*!\n * define what comparators are traversable\n */\n\nconst traversable = {\n    $and: true\n  , $or: true\n  , $nor: true\n}\n\n/*!\n * helper function for setting defaults\n */\n\nfunction _defaults (a: Record<string, unknown>, b: Record<string, unknown>) {\n  if (a && b) {\n    for (var key in b) {\n      if ('undefined' == typeof a[key])\n        a[key] = b[key];\n    }\n  }\n  return a;\n}\n\n/*!\n * Main exports\n */\n\n// module.exports = Filtr;\ntype Value = string | number | boolean | null;\ntype Comparator = keyof typeof Filtr.comparators;\n\nexport type Query = {\n  [k in Comparator]?: k extends Extract<Comparator, keyof typeof traversable> ? Query[]: k extends Extract<Comparator, \"$lt\" | \"$gt\"> ? string | number : string | number | boolean | null\n}\n\n\n/**\n * # Filtr (constructor)\n *\n * Constructor for creating a new filtr.\n *\n *    var query = filtr({ $gt: 5 })\n *      , alsoq = new filtr({ $gt: 5 });\n *\n * See the README or Filtr.comparators for constructing\n * well formed queries.\n *\n * @param {Object} query\n */\nexport class Filtr {\n    query: unknown;\n    stack: unknown[];\n    constructor(query: Query){\n        this.query = query;      \n        this.stack = parseQuery(query);\n    }\n    \n    /**\n    * ## .comparators\n    *\n    * Object containing all query compators.\n    */\n\n    static comparators = {\n        $gt: function (a: Extract<Value, string | number>, b: Extract<Value, string | number>) {\n          return a > b;\n        }\n      \n        , $gte: function (a: Extract<Value, string | number>, b: Extract<Value, string | number>) {\n          return a >= b;\n        }\n      \n        , $lt: function (a: Extract<Value, string | number>, b: Extract<Value, string | number>) {\n          return a < b;\n        }\n      \n        , $lte: function (a: Extract<Value, string | number>, b: Extract<Value, string | number>) {\n          return a <= b;\n        }\n      \n        , $all: function (a: any, b: any) {\n          for (var i = 0; i < b.length; i++) {\n            if (!~a.indexOf(b[i])) return false;\n          }\n          return true;\n        }\n      \n        , $exists: function (a: any, b: any) {\n          return !!a == b;\n        }\n      \n        , $mod: function (a: any, b: any) {\n          return a % b[0] == b[1];\n        }\n      \n        , $eq: function (a: Value, b: Value) {\n          return a == b;\n        }\n      \n        , $ne: function (a: Value, b: Value) {\n          return a != b;\n        }\n      \n        , $in: function (a: string, b: string) {\n          return ~b.indexOf(a) ? true : false;\n        }\n      \n        , $nin: function (a: string, b: string) {\n          return ~b.indexOf(a) ? false : true;\n        }\n      \n        , $size: function (a: any, b: any) {\n          return (a.length && b) ? a.length == b : false;\n        }\n      \n        , $or: function (a: any[]) {\n          var res = false;\n          for (var i = 0; i < a.length; i++) {\n            var fn = a[i];\n            if (fn) res = true;\n          }\n          return res;\n        }\n      \n        , $nor: function (a: any) {\n          var res = true;\n          for (var i = 0; i < a.length; i++) {\n            var fn = a[i];\n            if (fn) res = false;\n          }\n          return res;\n        }\n      \n        , $and: function (a: any[]) {\n          var res = true;\n          for (var i = 0; i < a.length; i++) {\n            var fn = a[i];\n            if (!fn) res = false;\n          }\n          return res;\n        }\n    };\n\n    /**\n     * # .getPathValue(path, object)\n     *\n     * This is a convience function offed by Filtr to allow\n     * the retrieval of values in an object given a string path.\n     *\n     *     var obj = {\n     *         prop1: {\n     *             arr: ['a', 'b', 'c']\n     *           , str: 'Hello'\n     *         }\n     *       , prop2: {\n     *             arr: [ { nested: 'Universe' } ]\n     *           , str: 'Hello again!'\n     *         }\n     *     }\n     *\n     * The following would be the results.\n     *\n     *     filtr.getPathValue('prop1.str', obj); // Hello\n     *     filtr.getPathValue('prop1.att[2]', obj); // b\n     *     filtr.getPathValue('prop2.arr[0].nested', obj); // Universe\n     *\n     * @param {String} path\n     * @param {Object} object\n     * @returns {Object} value or `undefined`\n     */\n\n    static getPathValue(path: string, obj: Record<string, any>) {\n        var parsed = parsePath(path);\n        return getPathValue(parsed, obj);\n    };    \n\n\n    /**\n     * # .setPathValue(path, value, object)\n     *\n     * This is a convience function offered by Filtr to allow\n     * the defining of a value in an object at a given string path.\n     *\n     *     var obj = {\n     *         prop1: {\n     *             arr: ['a', 'b', 'c']\n     *           , str: 'Hello'\n     *         }\n     *       , prop2: {\n     *             arr: [ { nested: 'Universe' } ]\n     *           , str: 'Hello again!'\n     *         }\n     *     }\n     *\n     * The following would be acceptable.\n     *\n     *     filtr.setPathValue('prop1.str', 'Hello Universe!', obj);\n     *     filtr.setPathValue('prop1.arr[2]', 'B', obj);\n     *     filtr.setPathValue('prop2.arr[0].nested.value', { hello: 'universe' }, obj);\n     *\n     * @param {String} path\n     * @param {*} value\n     * @param {Object} object\n     * @api public\n     */\n\n    static setPathValue(path: string, val: any, obj: Record<string, any>) {\n        var parsed = parsePath(path);\n        setPathValue(parsed, val, obj);\n    };\n\n\n    /**\n     * # .test(data, [options]);\n     *\n     * The primary testing mechanism for `Filtr` can be\n     * configured to return any number of possible formats.\n     *\n     * ### Options\n     *\n     * * *type*: input modifier\n     * * * `set`: (default) assert that the data provided is an array. test each item.\n     * * * `single`: assert that the data provided is a single item. return boolean.\n     * * *spec*: output modifer\n     * * * `subset`: (default) return an array containing a subset of matched items\n     * * * `boolean`: return an array of the original length with each item being a boolean when object passed or failed.\n     * * * `index`: return an array of numbers matching the index of passed object in the original array\n     *\n     * @param {Array|Object} data to test. must be an array unless option `type: 'single'`.\n     * @param {Object} options (optional)\n     * @returns {Array|Boolean} result based on options\n     */\n\n    test(data: Record<string, any>[] | Record<string, any>, opts: Record<string, any>) {\n        let defaults = {\n          type: 'set', // set || single\n          spec: 'subset' // subset || boolean || index\n        }\n        , options = _defaults(opts || {}, defaults)\n        , res = (options.type == 'single') ? false : [] as any[]\n        let dataList: Record<string, any>[] = options.type == 'single' ? [data] : data as Record<string, any>[];\n        // if (options.type == 'single') dataList = [ data ];\n        // if (options.type == 'single') data = [ data ];\n        for (var di = 0, dl = dataList.length; di < dl; di++) {\n          var datum = dataList[di]\n            , pass = testFilter(datum, this.stack);\n          if (options.type == 'single') {\n            res = pass;\n          } else {\n            res = res  as any[]\n            switch (options.spec) {\n            case 'boolean':\n                res.push(pass);\n                break;\n            case 'index':\n                if (pass) res.push(di);\n                break;\n            default:\n                if (pass) res.push(datum);\n                break;\n            }\n          }\n        }\n        return res;\n    };    \n  \n}\n\n/*!\n * Version number\n */\n\n// Filtr.version = '0.3.0';\n\n\n/*!\n * ## parsePath(path)\n *\n * Helper function used to parse string object\n * paths. Use in conjunction with `getPathValue`.\n *\n *      var parsed = parsePath('myobject.property.subprop');\n *\n * ### Paths:\n *\n * * Can be as near infinitely deep and nested\n * * Arrays are also valid using the formal `myobject.document[3].property`.\n *\n * @param {String} path\n * @returns {Object} parsed\n */\n\nfunction parsePath (path: string) {\n  var str = path.replace(/\\[/g, '.[')\n    , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return (parts || []).map(function (value) {\n    var re = /\\[(\\d+)\\]$/\n      , mArr = re.exec(value)\n    if (mArr) return { i: parseFloat(mArr[1]) };\n    else return { p: value };\n  });\n};\n\n/**\n * ## getPathValue(parsed, obj)\n *\n * Helper companion function for `.parsePath` that returns\n * the value located at the parsed address.\n *\n *      var value = getPathValue(parsed, obj);\n *\n * @param {Object} parsed definition from `parsePath`.\n * @param {Object} object to search against\n * @returns {Object|Undefined} value\n */\n\nfunction getPathValue (parsed: Record<string, any>[], obj: Record<string, any>) {\n  var tmp = obj\n    , res;\n  for (var i = 0, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n    if (tmp) {\n      if ('undefined' !== typeof part.p)\n        tmp = tmp[part.p];\n      else if ('undefined' !== typeof part.i)\n        tmp = tmp[part.i];\n      if (i == (l - 1)) res = tmp;\n    } else {\n      res = undefined;\n    }\n  }\n  return res;\n};\n\n/**\n * ## setPathValue (parsed, value, obj)\n *\n * Helper companion function for `parsePath` that sets\n * the value located at a parsed address.\n *\n *      setPathValue(parsed, 'value', obj);\n *\n * @param {Object} parsed definition from `parsePath`\n * @param {*} value to use upon set\n * @param {Object} object to search and define on\n * @api private\n */\n\nfunction setPathValue (parsed: Record<string, any>, val: any, obj: Record<string, any>) {\n  var tmp = obj;\n  for (var i = 0, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n    if ('undefined' !== typeof tmp) {\n      if (i == (l - 1)) {\n        if ('undefined' !== typeof part.p)\n          tmp[part.p] = val;\n        else if ('undefined' !== typeof part.i)\n          tmp[part.i] = val;\n      } else {\n        if ('undefined' !== typeof part.p && tmp[part.p])\n          tmp = tmp[part.p];\n        else if ('undefined' !== typeof part.i && tmp[part.i])\n          tmp = tmp[part.i];\n        else {\n          var next = parsed[i + 1];\n          if ('undefined' !== typeof part.p) {\n            tmp[part.p] = {};\n            tmp = tmp[part.p];\n          } else if ('undefined' !== typeof part.i) {\n            tmp[part.i] = [];\n            tmp = tmp[part.i]\n          }\n        }\n      }\n    } else {\n      if (i == (l - 1)) tmp = val;\n      else if ('undefined' !== typeof part.p)\n        tmp = {};\n      else if ('undefined' !== typeof part.i)\n        tmp = [];\n    }\n  }\n};\n\n/*!\n * ## parseQuery(query)\n *\n * Given the query input, create a reusable definition\n * for how to test data again the query.\n *\n * @param {Object} query\n * @returns {Array} stack to be used with `Filtr.prototype.test`\n */\n\nfunction parseQuery(query: Query) {\n  let stack = [];\n\n  for (let c in query) {\n    const cmd = c as Comparator;\n    let qry = {} as {\n      test: any,\n      path: any\n    }\n    var params = query[cmd];\n    if (cmd[0] == '$') {\n      qry.test = parseFilter(query);\n    } else {\n      if ('string' == typeof params\n      || 'number' == typeof params\n      || 'boolean' == typeof params) {\n        qry.test = parseFilter({ $eq: params });\n        qry.path = parsePath(cmd);\n      } else {\n        qry.test = parseFilter(params as Query);\n        qry.path = parsePath(cmd);\n      }\n    }\n    stack.push(qry);\n  }\n  return stack;\n};\n\n/*!\n * ## parseFilter (query)\n *\n * Given that the root object passed is a comparator definition,\n * return a consumable test definition.\n *\n * @param {Object} query\n * @returns {Array} stack for use as input with `testFilter`\n */\n\ntype Test<T> = keyof T;\nconst a = Filtr.comparators;\ntype keys = Test<typeof a>\n\nfunction parseFilter(query: Query) {\n  var stack = [];\n  for (let t in query) {\n    const test = t as Comparator\n    const tt = test;\n    // if(test in Object.keys(Filtr.comparators)){\n    //     Filtr.comparators[test];\n    // }\n    \n    var fn = Filtr.comparators[tt]\n      , params = query[test] as Query[]\n      , traverse = false;\n    let st = [];\n    let nq;\n    if (traversable[test as keyof typeof traversable]) {\n      traverse = true;\n      for (var i = 0; i < params.length; i++) {\n        nq = undefined;\n        var p = params[i];\n        if ('string' == typeof p\n        ||  'number' == typeof p\n        ||  'boolean' == typeof p) {\n          traverse = false\n        } else {\n          nq = parseQuery(p);\n        }\n        st.push(nq);\n      }\n    }\n    stack.push({\n        fn: fn\n      , params: traverse ? st : params\n      , traverse: traverse\n    });\n  }\n  return stack;\n};\n\n/*!\n * ## testFilter(value, stack)\n *\n * Given a well-formed stack from `parseFilter`, test\n * a given value again the stack.\n *\n * As the value is passed to a comparator, if that comparator\n * can interpret the value, false will be return. IE $gt: 'hello'\n *\n * @param {Object} value for consumption by comparator test\n * @param {Array} stack from `parseFilter`\n * @returns {Boolean} result\n * @api private\n */\n\nfunction testFilter (val: any, stack: any) {\n  var pass = true;\n  for (var si = 0, sl = stack.length; si < sl; si++) {\n    var filter = stack[si]\n      , el = (filter.path) ? getPathValue(filter.path, val) : val;\n    if (!_testFilter(el, filter.test)) pass = false;\n  }\n  return pass;\n};\n\nfunction _testFilter (val: any, stack: any[]) {\n  var res = true;\n  for (var i = 0; i < stack.length; i++) {\n    var test = stack[i]\n      , params = test.params;\n    if (test.traverse) {\n      var p = [];\n      for (var ii = 0; ii < params.length; ii++)\n        p.push(testFilter(val, params[ii]));\n      params = p;\n    }\n    if (test.fn.length == 1) {\n      if (!test.fn(params)) res = false;\n    } else {\n      if (!test.fn(val, params)) res = false;\n    }\n  }\n  return res;\n};\n\nexport function filter(query: Query){\n  return new Filtr(query);\n}","const NOT_VALID = \"provide a valid input\";\n\nexport function isObjectLiteral<T extends object = {}>(_obj: T) {\n    return (Object.getPrototypeOf(Object.getPrototypeOf(_obj)) === null);\n}\n\nexport function isEmptyObject<T extends object = {}>(obj: T){\n    return Object.keys(obj).length===0;\n}\n\nexport function validateInput<T extends object = {}>(obj: T): Error | void {\n    if (!obj || !isObjectLiteral(obj)){\n      throw new Error(NOT_VALID);\n    }\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCA,IAAAA,oBAAqB;;;ACDrB,sBAA0C;AAC1C,uBAAqB;AACrB,kBAA2B;;;ACS3B,IAAM,cAAc;AAAA,EAChB,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AACV;AAMA,SAAS,UAAWC,IAA4B,GAA4B;AAC1E,MAAIA,MAAK,GAAG;AACV,aAAS,OAAO,GAAG;AACjB,UAAI,eAAe,OAAOA,GAAE,GAAG;AAC7B,QAAAA,GAAE,GAAG,IAAI,EAAE,GAAG;AAAA,IAClB;AAAA,EACF;AACA,SAAOA;AACT;AA4BO,IAAM,QAAN,MAAY;AAAA,EACf;AAAA,EACA;AAAA,EACA,YAAY,OAAa;AACrB,SAAK,QAAQ;AACb,SAAK,QAAQ,WAAW,KAAK;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,cAAc;AAAA,IACjB,KAAK,SAAUA,IAAoC,GAAoC;AACrF,aAAOA,KAAI;AAAA,IACb;AAAA,IAEE,MAAM,SAAUA,IAAoC,GAAoC;AACxF,aAAOA,MAAK;AAAA,IACd;AAAA,IAEE,KAAK,SAAUA,IAAoC,GAAoC;AACvF,aAAOA,KAAI;AAAA,IACb;AAAA,IAEE,MAAM,SAAUA,IAAoC,GAAoC;AACxF,aAAOA,MAAK;AAAA,IACd;AAAA,IAEE,MAAM,SAAUA,IAAQ,GAAQ;AAChC,eAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,YAAI,CAAC,CAACA,GAAE,QAAQ,EAAE,CAAC,CAAC,EAAG,QAAO;AAAA,MAChC;AACA,aAAO;AAAA,IACT;AAAA,IAEE,SAAS,SAAUA,IAAQ,GAAQ;AACnC,aAAO,CAAC,CAACA,MAAK;AAAA,IAChB;AAAA,IAEE,MAAM,SAAUA,IAAQ,GAAQ;AAChC,aAAOA,KAAI,EAAE,CAAC,KAAK,EAAE,CAAC;AAAA,IACxB;AAAA,IAEE,KAAK,SAAUA,IAAU,GAAU;AACnC,aAAOA,MAAK;AAAA,IACd;AAAA,IAEE,KAAK,SAAUA,IAAU,GAAU;AACnC,aAAOA,MAAK;AAAA,IACd;AAAA,IAEE,KAAK,SAAUA,IAAW,GAAW;AACrC,aAAO,CAAC,EAAE,QAAQA,EAAC,IAAI,OAAO;AAAA,IAChC;AAAA,IAEE,MAAM,SAAUA,IAAW,GAAW;AACtC,aAAO,CAAC,EAAE,QAAQA,EAAC,IAAI,QAAQ;AAAA,IACjC;AAAA,IAEE,OAAO,SAAUA,IAAQ,GAAQ;AACjC,aAAQA,GAAE,UAAU,IAAKA,GAAE,UAAU,IAAI;AAAA,IAC3C;AAAA,IAEE,KAAK,SAAUA,IAAU;AACzB,UAAI,MAAM;AACV,eAAS,IAAI,GAAG,IAAIA,GAAE,QAAQ,KAAK;AACjC,YAAI,KAAKA,GAAE,CAAC;AACZ,YAAI,GAAI,OAAM;AAAA,MAChB;AACA,aAAO;AAAA,IACT;AAAA,IAEE,MAAM,SAAUA,IAAQ;AACxB,UAAI,MAAM;AACV,eAAS,IAAI,GAAG,IAAIA,GAAE,QAAQ,KAAK;AACjC,YAAI,KAAKA,GAAE,CAAC;AACZ,YAAI,GAAI,OAAM;AAAA,MAChB;AACA,aAAO;AAAA,IACT;AAAA,IAEE,MAAM,SAAUA,IAAU;AAC1B,UAAI,MAAM;AACV,eAAS,IAAI,GAAG,IAAIA,GAAE,QAAQ,KAAK;AACjC,YAAI,KAAKA,GAAE,CAAC;AACZ,YAAI,CAAC,GAAI,OAAM;AAAA,MACjB;AACA,aAAO;AAAA,IACT;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA8BA,OAAO,aAAa,MAAc,KAA0B;AACxD,QAAI,SAAS,UAAU,IAAI;AAC3B,WAAO,aAAa,QAAQ,GAAG;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgCA,OAAO,aAAa,MAAc,KAAU,KAA0B;AAClE,QAAI,SAAS,UAAU,IAAI;AAC3B,iBAAa,QAAQ,KAAK,GAAG;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,KAAK,MAAmD,MAA2B;AAC/E,QAAI,WAAW;AAAA,MACb,MAAM;AAAA;AAAA,MACN,MAAM;AAAA;AAAA,IACR,GACE,UAAU,UAAU,QAAQ,CAAC,GAAG,QAAQ,GACxC,MAAO,QAAQ,QAAQ,WAAY,QAAQ,CAAC;AAC9C,QAAI,WAAkC,QAAQ,QAAQ,WAAW,CAAC,IAAI,IAAI;AAG1E,aAAS,KAAK,GAAG,KAAK,SAAS,QAAQ,KAAK,IAAI,MAAM;AACpD,UAAI,QAAQ,SAAS,EAAE,GACnB,OAAO,WAAW,OAAO,KAAK,KAAK;AACvC,UAAI,QAAQ,QAAQ,UAAU;AAC5B,cAAM;AAAA,MACR,OAAO;AACL,cAAM;AACN,gBAAQ,QAAQ,MAAM;AAAA,UACtB,KAAK;AACD,gBAAI,KAAK,IAAI;AACb;AAAA,UACJ,KAAK;AACD,gBAAI,KAAM,KAAI,KAAK,EAAE;AACrB;AAAA,UACJ;AACI,gBAAI,KAAM,KAAI,KAAK,KAAK;AACxB;AAAA,QACJ;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACX;AAEJ;AA0BA,SAAS,UAAW,MAAc;AAChC,MAAI,MAAM,KAAK,QAAQ,OAAO,IAAI,GAC9B,QAAQ,IAAI,MAAM,iBAAiB;AACvC,UAAQ,SAAS,CAAC,GAAG,IAAI,SAAU,OAAO;AACxC,QAAI,KAAK,cACL,OAAO,GAAG,KAAK,KAAK;AACxB,QAAI,KAAM,QAAO,EAAE,GAAG,WAAW,KAAK,CAAC,CAAC,EAAE;AAAA,QACrC,QAAO,EAAE,GAAG,MAAM;AAAA,EACzB,CAAC;AACH;AAeA,SAAS,aAAc,QAA+B,KAA0B;AAC9E,MAAI,MAAM,KACN;AACJ,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,IAAI,GAAG,KAAK;AAC7C,QAAI,OAAO,OAAO,CAAC;AACnB,QAAI,KAAK;AACP,UAAI,gBAAgB,OAAO,KAAK;AAC9B,cAAM,IAAI,KAAK,CAAC;AAAA,eACT,gBAAgB,OAAO,KAAK;AACnC,cAAM,IAAI,KAAK,CAAC;AAClB,UAAI,KAAM,IAAI,EAAI,OAAM;AAAA,IAC1B,OAAO;AACL,YAAM;AAAA,IACR;AAAA,EACF;AACA,SAAO;AACT;AAgBA,SAAS,aAAc,QAA6B,KAAU,KAA0B;AACtF,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,IAAI,GAAG,KAAK;AAC7C,QAAI,OAAO,OAAO,CAAC;AACnB,QAAI,gBAAgB,OAAO,KAAK;AAC9B,UAAI,KAAM,IAAI,GAAI;AAChB,YAAI,gBAAgB,OAAO,KAAK;AAC9B,cAAI,KAAK,CAAC,IAAI;AAAA,iBACP,gBAAgB,OAAO,KAAK;AACnC,cAAI,KAAK,CAAC,IAAI;AAAA,MAClB,OAAO;AACL,YAAI,gBAAgB,OAAO,KAAK,KAAK,IAAI,KAAK,CAAC;AAC7C,gBAAM,IAAI,KAAK,CAAC;AAAA,iBACT,gBAAgB,OAAO,KAAK,KAAK,IAAI,KAAK,CAAC;AAClD,gBAAM,IAAI,KAAK,CAAC;AAAA,aACb;AACH,cAAI,OAAO,OAAO,IAAI,CAAC;AACvB,cAAI,gBAAgB,OAAO,KAAK,GAAG;AACjC,gBAAI,KAAK,CAAC,IAAI,CAAC;AACf,kBAAM,IAAI,KAAK,CAAC;AAAA,UAClB,WAAW,gBAAgB,OAAO,KAAK,GAAG;AACxC,gBAAI,KAAK,CAAC,IAAI,CAAC;AACf,kBAAM,IAAI,KAAK,CAAC;AAAA,UAClB;AAAA,QACF;AAAA,MACF;AAAA,IACF,OAAO;AACL,UAAI,KAAM,IAAI,EAAI,OAAM;AAAA,eACf,gBAAgB,OAAO,KAAK;AACnC,cAAM,CAAC;AAAA,eACA,gBAAgB,OAAO,KAAK;AACnC,cAAM,CAAC;AAAA,IACX;AAAA,EACF;AACF;AAYA,SAAS,WAAW,OAAc;AAChC,MAAI,QAAQ,CAAC;AAEb,WAAS,KAAK,OAAO;AACnB,UAAM,MAAM;AACZ,QAAI,MAAM,CAAC;AAIX,QAAI,SAAS,MAAM,GAAG;AACtB,QAAI,IAAI,CAAC,KAAK,KAAK;AACjB,UAAI,OAAO,YAAY,KAAK;AAAA,IAC9B,OAAO;AACL,UAAI,YAAY,OAAO,UACpB,YAAY,OAAO,UACnB,aAAa,OAAO,QAAQ;AAC7B,YAAI,OAAO,YAAY,EAAE,KAAK,OAAO,CAAC;AACtC,YAAI,OAAO,UAAU,GAAG;AAAA,MAC1B,OAAO;AACL,YAAI,OAAO,YAAY,MAAe;AACtC,YAAI,OAAO,UAAU,GAAG;AAAA,MAC1B;AAAA,IACF;AACA,UAAM,KAAK,GAAG;AAAA,EAChB;AACA,SAAO;AACT;AAaA,IAAM,IAAI,MAAM;AAGhB,SAAS,YAAY,OAAc;AACjC,MAAI,QAAQ,CAAC;AACb,WAAS,KAAK,OAAO;AACnB,UAAM,OAAO;AACb,UAAM,KAAK;AAKX,QAAI,KAAK,MAAM,YAAY,EAAE,GACzB,SAAS,MAAM,IAAI,GACnB,WAAW;AACf,QAAI,KAAK,CAAC;AACV,QAAI;AACJ,QAAI,YAAY,IAAgC,GAAG;AACjD,iBAAW;AACX,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,aAAK;AACL,YAAI,IAAI,OAAO,CAAC;AAChB,YAAI,YAAY,OAAO,KACnB,YAAY,OAAO,KACnB,aAAa,OAAO,GAAG;AACzB,qBAAW;AAAA,QACb,OAAO;AACL,eAAK,WAAW,CAAC;AAAA,QACnB;AACA,WAAG,KAAK,EAAE;AAAA,MACZ;AAAA,IACF;AACA,UAAM,KAAK;AAAA,MACP;AAAA,MACA,QAAQ,WAAW,KAAK;AAAA,MACxB;AAAA,IACJ,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAiBA,SAAS,WAAY,KAAU,OAAY;AACzC,MAAI,OAAO;AACX,WAAS,KAAK,GAAG,KAAK,MAAM,QAAQ,KAAK,IAAI,MAAM;AACjD,QAAIC,UAAS,MAAM,EAAE,GACjB,KAAMA,QAAO,OAAQ,aAAaA,QAAO,MAAM,GAAG,IAAI;AAC1D,QAAI,CAAC,YAAY,IAAIA,QAAO,IAAI,EAAG,QAAO;AAAA,EAC5C;AACA,SAAO;AACT;AAEA,SAAS,YAAa,KAAU,OAAc;AAC5C,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,QAAI,OAAO,MAAM,CAAC,GACd,SAAS,KAAK;AAClB,QAAI,KAAK,UAAU;AACjB,UAAI,IAAI,CAAC;AACT,eAAS,KAAK,GAAG,KAAK,OAAO,QAAQ;AACnC,UAAE,KAAK,WAAW,KAAK,OAAO,EAAE,CAAC,CAAC;AACpC,eAAS;AAAA,IACX;AACA,QAAI,KAAK,GAAG,UAAU,GAAG;AACvB,UAAI,CAAC,KAAK,GAAG,MAAM,EAAG,OAAM;AAAA,IAC9B,OAAO;AACL,UAAI,CAAC,KAAK,GAAG,KAAK,MAAM,EAAG,OAAM;AAAA,IACnC;AAAA,EACF;AACA,SAAO;AACT;AAEO,SAAS,OAAO,OAAa;AAClC,SAAO,IAAI,MAAM,KAAK;AACxB;;;ACjhBA,IAAM,YAAY;AAEX,SAAS,gBAAuC,MAAS;AAC5D,SAAQ,OAAO,eAAe,OAAO,eAAe,IAAI,CAAC,MAAM;AACnE;AAEO,SAAS,cAAqC,KAAO;AACxD,SAAO,OAAO,KAAK,GAAG,EAAE,WAAS;AACrC;AAEO,SAAS,cAAqC,KAAsB;AACvE,MAAI,CAAC,OAAO,CAAC,gBAAgB,GAAG,GAAE;AAChC,UAAM,IAAI,MAAM,SAAS;AAAA,EAC3B;AACJ;;;AFPA,IAAMC,aAAY;AAKX,IAAM,aAAN,MAAM,YAAc;AAAA,EACf;AAAA,EACA,eAAmB,uBAAK,WAAW,UAAU;AAAA,EAErD,YAAY,UAAkB,UAAkB;AAC5C,SAAK,WAAW;AAChB,SAAK,WAAW,YAAY,KAAK;AAAA,EACrC;AAAA,EAEA,aAAa,OAAuB,UAAkB,UAAsD;AACxG,QAAI,OAAO,WAAW,MAAM,SAAS,MAAM,GAAG,EAAE,KAAK,GAAG;AACxD,YAAQ;AACR,QAAG;AACC,gBAAM,sBAAK,IAAI;AAAA,IACnB,SAAO,KAAK;AACR,gBAAM,2BAAU,MAAM,EAAE;AAAA,IAC5B;AACA,WAAO,IAAI,YAA2B,UAAU,QAAQ;AAAA,EAC5D;AAAA,EAEQ,UAAU;AACd,QAAI,OAAO,KAAK,WAAW,MAAM,KAAK,SAAS,MAAM,GAAG,EAAE,KAAK,GAAG;AAClE,YAAQ;AACR,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,OAAO,KAAsC;AAE/C,QAAQ,cAAc,GAAU,EAAG,OAAMA;AACzC,QAAI,gBAAY,YAAAC,IAAK;AACrB,QAAI,OAAO,KAAK,QAAQ;AACxB,UAAM,OAAO,OAAO;AAAA,MAChB,OAAO;AAAA,IACX,GAAG,GAAG;AACN,QAAI;AACA,UAAI,WAAmB,UAAM,0BAAS,MAAM,OAAO,KAAK;AACxD,YAAM,OAAa,KAAK,MAAM,QAAQ;AACtC,WAAK,KAAK,GAAG;AACb,iBAAW,KAAK,UAAU,IAAI;AAC9B,iBAAO,2BAAU,MAAM,QAAQ;AAAA,IACnC,SAAS,KAAK;AACV,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,MAAM,KAAK,OAA8B;AACrC,QAAI,OAAO,KAAK,QAAQ;AACxB,UAAM,WAAW,OAAO,KAAY;AAEpC,QAAI,WAAmB,UAAM,0BAAS,MAAM,OAAO;AAEnD,QAAI;AACA,UAAI,UAAU,KAAK,MAAM,QAAQ;AACjC,YAAM,cAAc,SAAS,KAAK,SAAS,KAAK;AAChD,aAAO;AAAA,IACX,SAAS,KAAK;AAAA,IAAC;AAAA,EACnB;AAAA,EAEA,MAAM,OAAO,OAA8B,KAAiB;AACxD,IAAK,cAAc,KAAK;AACxB,IAAK,cAAc,GAAG;AAEtB,UAAM,WAAW,OAAO,KAAY;AACpC,QAAI,WAAmB,UAAM,0BAAS,KAAK,QAAQ,GAAG,OAAO;AAC7D,QAAI;AACA,UAAI,UAAU,KAAK,MAAM,QAAQ;AACjC,YAAM,UAAU,SAAS,KAAK,SAAS,KAAK;AAC5C,MAAC,QAAkB,QAAQ,CAAC,QAAQ;AAChC,iBAAS,OAAO,KAAK;AACjB,cAAI,IAAI,eAAe,GAAG,GAAG;AACzB,gBAAI,GAAG,IAAI,IAAI,GAAG;AAAA,UACtB;AAAA,QACJ;AAAA,MACJ,CAAC;AAED,iBAAO,2BAAU,KAAK,QAAQ,GAAG,KAAK,UAAU,OAAO,CAAC;AAAA,IAE5D,SAAS,KAAK;AAAA,IAAC;AAAA,EACnB;AAAA,EAEA,MAAM,OAAO,OAAW;AACpB,UAAM,WAAW,OAAO,KAAY;AACpC,QAAI,WAAmB,UAAM,0BAAS,KAAK,QAAQ,GAAG,OAAO;AAC7D,QAAI;AACA,UAAI,UAAU,KAAK,MAAM,QAAQ;AACjC,YAAM,cAAc,SAAS,KAAK,SAAS,KAAK;AAChD,YAAM,cAAc,QAAQ,OAAO,CAAC,WAAW;AAC3C,eAAO,YAAY,UAAU,OAAG,EAAE,QAAQ,OAAO,GAAG,MAAM;AAAA,MAC9D,CAAC;AAED,iBAAO,2BAAU,KAAK,QAAQ,GAAG,KAAK,UAAU,WAAW,CAAC;AAAA,IAEhE,SAAS,KAAK;AAAA,IAAC;AAAA,EACnB;AACJ;;;ADvGA,IAAAC,mBAA4B;AAGrB,IAAM,KAAN,MAAM,IAAG;AAAA,EACZ,OAAe,gBAAoB,wBAAK,WAAW,YAAY;AAAA,EACvD,eAAe,oBAAI,IAA6C;AAAA,EAChE,WAAY,CAAC;AAAA,EACZ;AAAA,EACT,YAAY,MAAa;AACrB,SAAK,OAAO;AAAA,EAUhB;AAAA,EAEA,OAAO,QAAQ,MAAuB;AAClC,WAAO,KAAK,YAAY,OAAO,QAAQ,KAAK;AAAA,EAChD;AAAA,EAEA,aAAa,OAAO,MAAc,UAAmB;AACjD,SAAK,YAAY,YAAY,KAAK;AAGlC,QAAG;AACC,gBAAM,uBAAK,KAAK,SAAS;AAAA,IAC7B,SAAO,KAAI;AAEP,gBAAM,4BAAM,wBAAK,KAAK,WAAW,IAAI,GAAG;AAAA,QACpC,WAAW;AAAA,MACf,CAAC;AAAA,IACL;AACA,WAAO,IAAI,IAAG,IAAI;AAAA,EACtB;AAAA,EAEA,UAAU;AACN,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,OAAO,IAAI,MAAc;AACrB,QAAI,OAAO,KAAK,QAAQ,IAAI;AAC5B,WAAO,IAAI,IAAG,IAAI;AAAA,EACtB;AAAA,EAEA,MAAM,cAA4B,MAAsC;AACpE,QAAI,aAAa,KAAK,aAAa,IAAI,IAAI;AAC3C,QAAG,CAAC,YAAY;AACZ,mBAAa,MAAM,WAAW,OAAU,IAAG,WAAW,KAAK,OAAO,MAAM,IAAI;AAC5E,WAAK,aAAa,IAAI,MAAM,UAAU;AAAA,IAC1C;AACA,SAAK,WAAW;AAChB,WAAO;AAAA,EACX;AAAA,EAEA,iBAAiB,MAAa;AAC1B,SAAK,aAAa,OAAO,IAAI;AAAA,EACjC;AAAA,EAEA,oBAAoB;AAAA,EAEpB;AAAA,EAEA,oBAAmB;AAAA,EAEnB;AAEJ;","names":["import_node_path","a","filter","NOT_VALID","uuid","import_promises"]}